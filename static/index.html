<!DOCTYPE html>
<html>

<head>
  <title>Strava GPX Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
    }

    #sidebar {
      width: 300px;
      height: 100vh;
      overflow-y: auto;
      background: #f8f9fa;
      border-right: 1px solid #dee2e6;
      padding: 10px;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 14px;
    }

    #sidebar h3 {
      margin: 0 0 10px 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #dee2e6;
    }

    .track-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin: 4px 0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .track-item:hover {
      background: #e9ecef;
    }

    .track-item input {
      margin-right: 10px;
      flex-shrink: 0;
    }

    .track-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      margin-right: 8px;
      flex-shrink: 0;
    }

    .track-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .track-distance {
      color: #666;
      margin-left: 8px;
      white-space: nowrap;
      font-size: 12px;
    }

    #map {
      flex: 1;
      height: 100vh;
    }

    .controls {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #dee2e6;
    }

    .controls button {
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }

    .tile-controls {
      margin-bottom: 10px;
      padding: 10px;
      background: white;
      border-radius: 4px;
    }

    .tile-controls label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .tile-controls input {
      margin-right: 8px;
    }

    .tile-stats {
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }

    .tile-stats .count {
      font-weight: bold;
      color: #333;
      font-size: 16px;
    }

    .gemeinde-tooltip {
      font-size: 13px;
    }
    .gemeinde-tooltip b {
      font-size: 14px;
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <h3>GPX Tracks</h3>
    <div class="tile-controls">
      <label>
        <input type="checkbox" id="show-tiles" checked>
        Besuchte Tiles anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-gemeinden" checked>
        Gemeindegrenzen anzeigen
      </label>
      <div class="tile-stats">
        <span class="count" id="tile-count">-</span> Tiles besucht (Zoom 14)
      </div>
    </div>
    <div class="controls">
      <button onclick="toggleAll(true)">Alle an</button>
      <button onclick="toggleAll(false)">Alle aus</button>
    </div>
    <div id="track-list"></div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([51.25, 12.14], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Create custom panes for z-ordering: gemeinden below tiles
    map.createPane('gemeindenPane');
    map.getPane('gemeindenPane').style.zIndex = 400;
    
    map.createPane('tilesPane');
    map.getPane('tilesPane').style.zIndex = 450;

    const tracks = {};
    const tilesLayer = L.layerGroup().addTo(map);
    const gemeindenLayer = L.layerGroup().addTo(map);
    let tilesVisible = true;

    // Convert tile coordinates to lat/lon bounds
    function tileToLatLngBounds(x, y, z) {
      const n = Math.pow(2, z);
      const lonMin = x / n * 360.0 - 180.0;
      const lonMax = (x + 1) / n * 360.0 - 180.0;
      const latMax = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180.0 / Math.PI;
      const latMin = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180.0 / Math.PI;
      return L.latLngBounds([latMin, lonMin], [latMax, lonMax]);
    }

    // Format timestamp to readable date
    function formatTileDate(timestamp) {
      if (!timestamp || timestamp === 0) {
        return 'Datum unbekannt';
      }
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Get color based on how recent the tile was visited
    // Newest = dark green, oldest = light green/yellow
    function getTileColor(timestamp, minTime, maxTime) {
      if (!timestamp || timestamp === 0 || minTime === maxTime) {
        return '#90EE90'; // Light green for unknown dates
      }

      // Calculate ratio: 1 = newest, 0 = oldest
      const ratio = (timestamp - minTime) / (maxTime - minTime);

      // Gradient from light green (oldest) to dark green (newest)
      // Light green: rgb(144, 238, 144) -> Dark green: rgb(34, 139, 34)
      const r = Math.round(144 - ratio * 110);
      const g = Math.round(238 - ratio * 99);
      const b = Math.round(144 - ratio * 110);

      return `rgb(${r}, ${g}, ${b})`;
    }

    // Load and display visited tiles
    function loadTiles() {
      fetch('/tiles').then(r => r.json()).then(data => {
        document.getElementById('tile-count').textContent = data.total_count;

        // Find min and max timestamps for color scaling
        const timestamps = data.tiles
          .map(t => t.first_visited_at)
          .filter(t => t && t > 0);
        const minTime = Math.min(...timestamps);
        const maxTime = Math.max(...timestamps);

        data.tiles.forEach(tile => {
          const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
          const dateStr = formatTileDate(tile.first_visited_at);
          const title = tile.activity_title || 'Unbekannt';
          const activityId = tile.activity_id || '';
          const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);

          let tooltipContent = `<b>${title}</b><br>`;
          tooltipContent += `Erste Durchfahrt: ${dateStr}`;
          if (activityId) {
            tooltipContent += `<br>ID: ${activityId}`;
          }

          const rect = L.rectangle(bounds, {
            color: tileColor,
            weight: 1,
            fillColor: tileColor,
            fillOpacity: 0.5,
            interactive: true
          });
          rect.bindTooltip(tooltipContent, {
            sticky: true,
            direction: 'top'
          });
          tilesLayer.addLayer(rect);
        });
      });
    }

    // Toggle tiles visibility
    document.getElementById('show-tiles').addEventListener('change', (e) => {
      tilesVisible = e.target.checked;
      if (tilesVisible) {
        tilesLayer.addTo(map);
      } else {
        tilesLayer.remove();
      }
    });

    // Toggle Gemeinden visibility
    let gemeindenVisible = true;
    document.getElementById('show-gemeinden').addEventListener('change', (e) => {
      gemeindenVisible = e.target.checked;
      if (gemeindenVisible) {
        gemeindenLayer.addTo(map);
      } else {
        gemeindenLayer.remove();
      }
    });

    // Store tiles globally for gemeinde calculation
    let allTiles = [];
    const TILE_ZOOM = 14;

    // Convert lat/lon to tile coordinates
    function latLonToTile(lat, lon, zoom) {
      const n = Math.pow(2, zoom);
      const x = Math.floor((lon + 180.0) / 360.0 * n);
      const latRad = lat * Math.PI / 180.0;
      const y = Math.floor((1.0 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2.0 * n);
      return { x, y };
    }

    // Get tile center coordinates
    function tileCenterToLatLon(x, y, zoom) {
      const n = Math.pow(2, zoom);
      const lon = (x + 0.5) / n * 360.0 - 180.0;
      const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 0.5) / n)));
      const lat = latRad * 180.0 / Math.PI;
      return [lat, lon];
    }

    // Check if a point is inside a polygon
    function pointInPolygon(point, polygon) {
      const x = point[1], y = point[0]; // lon, lat
      let inside = false;
      
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // Check if a point is in any polygon of a MultiPolygon or Polygon
    function pointInGeometry(point, geometry) {
      if (geometry.type === 'Polygon') {
        return pointInPolygon(point, geometry.coordinates[0]);
      } else if (geometry.type === 'MultiPolygon') {
        for (const poly of geometry.coordinates) {
          if (pointInPolygon(point, poly[0])) {
            return true;
          }
        }
      }
      return false;
    }

    // Get all tiles that fall within a geometry's bounding box, then filter
    function getTilesInGeometry(geometry, visitedTileSet) {
      // Get bounding box
      let minLat = Infinity, maxLat = -Infinity;
      let minLon = Infinity, maxLon = -Infinity;
      
      const coords = geometry.type === 'Polygon' 
        ? [geometry.coordinates]
        : geometry.coordinates;
      
      for (const poly of coords) {
        for (const ring of poly) {
          for (const [lon, lat] of ring) {
            minLat = Math.min(minLat, lat);
            maxLat = Math.max(maxLat, lat);
            minLon = Math.min(minLon, lon);
            maxLon = Math.max(maxLon, lon);
          }
        }
      }

      // Get tile range for bounding box
      const topLeft = latLonToTile(maxLat, minLon, TILE_ZOOM);
      const bottomRight = latLonToTile(minLat, maxLon, TILE_ZOOM);
      
      let totalTiles = 0;
      let visitedTiles = 0;
      
      // Check each tile in the bounding box
      for (let x = topLeft.x; x <= bottomRight.x; x++) {
        for (let y = topLeft.y; y <= bottomRight.y; y++) {
          const center = tileCenterToLatLon(x, y, TILE_ZOOM);
          if (pointInGeometry(center, geometry)) {
            totalTiles++;
            if (visitedTileSet.has(`${x},${y}`)) {
              visitedTiles++;
            }
          }
        }
      }
      
      return { totalTiles, visitedTiles };
    }

    // Store gemeinden data globally for tile lookups
    let gemeindenData = [];

    // Load Gemeinden and calculate statistics
    function loadGemeinden() {
      // First, create a set of visited tiles for fast lookup
      const visitedTileSet = new Set(allTiles.map(t => `${t.x},${t.y}`));
      
      fetch('/gemeinden.geojson')
        .then(r => r.json())
        .then(geojson => {
          // Filter to only show "Gemeinde" features (not Bundesland, Kreis, etc.)
          const gemeinden = geojson.features.filter(f => 
            f.properties.Art === 'Gemeinde' || 
            f.properties.Art === 'Stadt' ||
            f.properties.Art === 'Kreisfreie Stadt'
          );
          
          gemeinden.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.Name || 'Unbekannt';
            const percent = stats.totalTiles > 0 
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100) 
              : 0;
            
            // Store gemeinde data for tile tooltip lookup
            gemeindenData.push({
              name: name,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });
            
            // Render gemeinde borders with interactivity for areas without tiles
            const layer = L.geoJSON(feature, {
              pane: 'gemeindenPane',
              style: {
                color: '#000000',
                weight: 2,
                fillColor: 'transparent',
                fillOpacity: 0,
                interactive: true
              }
            });
            
            // Add tooltip for gemeinde (shown when hovering outside tiles)
            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>${name}</b><br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }
            tooltipContent += `</div>`;
            
            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });
            
            gemeindenLayer.addLayer(layer);
          });
          
          // Now update tile tooltips with gemeinde info
          updateTileTooltipsWithGemeinden();
        })
        .catch(err => console.error('Error loading Gemeinden:', err));
    }

    // Find which gemeinde a tile belongs to
    function findGemeindeForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const gemeinde of gemeindenData) {
        if (pointInGeometry(center, gemeinde.geometry)) {
          return gemeinde;
        }
      }
      return null;
    }

    // Update tile tooltips after gemeinden are loaded
    function updateTileTooltipsWithGemeinden() {
      // Clear and rebuild tiles layer with gemeinde info
      tilesLayer.clearLayers();
      
      const timestamps = allTiles
        .map(t => t.first_visited_at)
        .filter(t => t && t > 0);
      const minTime = Math.min(...timestamps);
      const maxTime = Math.max(...timestamps);

      allTiles.forEach(tile => {
        const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
        const dateStr = formatTileDate(tile.first_visited_at);
        const title = tile.activity_title || 'Unbekannt';
        const activityId = tile.activity_id || '';
        const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);
        
        // Find gemeinde for this tile
        const gemeinde = findGemeindeForTile(tile.x, tile.y);

        let tooltipContent = `<b>${title}</b><br>`;
        tooltipContent += `Erste Durchfahrt: ${dateStr}`;
        if (activityId) {
          tooltipContent += `<br>ID: ${activityId}`;
        }
        
        // Add gemeinde info if found
        if (gemeinde) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>${gemeinde.name}</b><br>`;
          tooltipContent += `Tiles: ${gemeinde.stats.visitedTiles} / ${gemeinde.stats.totalTiles}`;
          if (gemeinde.stats.totalTiles > 0) {
            tooltipContent += ` (${gemeinde.percent}%)`;
          }
        }

        const rect = L.rectangle(bounds, {
          pane: 'tilesPane',
          color: tileColor,
          weight: 1,
          fillColor: tileColor,
          fillOpacity: 0.5,
          interactive: true
        });
        rect.bindTooltip(tooltipContent, {
          sticky: true,
          direction: 'top'
        });
        tilesLayer.addLayer(rect);
      });
    }

    // Modified loadTiles to also trigger Gemeinden loading
    const originalLoadTiles = loadTiles;
    loadTiles = function() {
      fetch('/tiles').then(r => r.json()).then(data => {
        document.getElementById('tile-count').textContent = data.total_count;
        allTiles = data.tiles; // Store for gemeinde calculation

        // Find min and max timestamps for color scaling
        const timestamps = data.tiles
          .map(t => t.first_visited_at)
          .filter(t => t && t > 0);
        const minTime = Math.min(...timestamps);
        const maxTime = Math.max(...timestamps);

        data.tiles.forEach(tile => {
          const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
          const dateStr = formatTileDate(tile.first_visited_at);
          const title = tile.activity_title || 'Unbekannt';
          const activityId = tile.activity_id || '';
          const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);

          let tooltipContent = `<b>${title}</b><br>`;
          tooltipContent += `Erste Durchfahrt: ${dateStr}`;
          if (activityId) {
            tooltipContent += `<br>ID: ${activityId}`;
          }

          const rect = L.rectangle(bounds, {
            pane: 'tilesPane',
            color: tileColor,
            weight: 1,
            fillColor: tileColor,
            fillOpacity: 0.5,
            interactive: true
          });
          rect.bindTooltip(tooltipContent, {
            sticky: true,
            direction: 'top'
          });
          tilesLayer.addLayer(rect);
        });

        // Now load Gemeinden with tile data available
        loadGemeinden();
      });
    };

    // Load tiles on startup
    loadTiles();

    // Generate color gradient from red (newest) to green (oldest)
    function getGradientColor(index, total) {
      if (total <= 1) return '#e6194b'; // red for single track
      const ratio = index / (total - 1);
      // Red: rgb(230, 25, 75) -> Green: rgb(60, 180, 75)
      const r = Math.round(230 - ratio * 170);
      const g = Math.round(25 + ratio * 155);
      const b = Math.round(75);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function updateBounds() {
      const visibleBounds = [];
      Object.values(tracks).forEach(t => {
        if (t.visible && t.polyline) visibleBounds.push(t.polyline.getBounds());
      });
      if (visibleBounds.length > 0) {
        let bounds = visibleBounds[0];
        visibleBounds.slice(1).forEach(b => bounds.extend(b));
        map.fitBounds(bounds);
      }
    }

    function toggleTrack(file, visible) {
      const track = tracks[file];
      if (!track || !track.polyline) return;
      track.visible = visible;
      if (visible) { track.polyline.addTo(map); } else { track.polyline.remove(); }
    }

    function toggleAll(visible) {
      Object.keys(tracks).forEach(file => {
        const checkbox = document.getElementById('chk-' + file);
        if (checkbox) checkbox.checked = visible;
        toggleTrack(file, visible);
      });
    }

    fetch('/gpx').then(r => r.json()).then(files => {
      const listEl = document.getElementById('track-list');
      const total = files.length;

      files.forEach((fileInfo, index) => {
        const file = fileInfo.filename;
        const color = getGradientColor(index, total);
        tracks[file] = { color: color, polyline: null, visible: true };

        const item = document.createElement('label');
        item.className = 'track-item';
        const dateStr = formatDate(fileInfo.modified);
        const distStr = fileInfo.distance_km.toFixed(2) + ' km';
        item.innerHTML = '<input type="checkbox" id="chk-' + file + '" checked><span class="track-color" style="background:' + color + '"></span><span class="track-name">' + dateStr + '</span><span class="track-distance">' + distStr + '</span>';
        item.querySelector('input').addEventListener('change', (e) => toggleTrack(file, e.target.checked));
        listEl.appendChild(item);

        fetch('/gpx/' + file).then(r => r.text()).then(gpxData => {
          const parser = new DOMParser();
          const gpx = parser.parseFromString(gpxData, 'text/xml');
          const trkpts = gpx.querySelectorAll('trkpt');
          if (trkpts.length === 0) return;
          const latlngs = [];
          trkpts.forEach(pt => {
            const lat = parseFloat(pt.getAttribute('lat'));
            const lon = parseFloat(pt.getAttribute('lon'));
            if (!isNaN(lat) && !isNaN(lon)) latlngs.push([lat, lon]);
          });
          if (latlngs.length > 0) {
            const polyline = L.polyline(latlngs, { color: color, weight: 3, opacity: 0.8 }).addTo(map);
            tracks[file].polyline = polyline;
            updateBounds();
          }
        });
      });
    });
  </script>
</body>

</html>