<!DOCTYPE html>
<html>

<head>
  <title>Strava GPX Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
    }

    #sidebar {
      width: 300px;
      height: 100vh;
      overflow-y: auto;
      background: #f8f9fa;
      border-right: 1px solid #dee2e6;
      padding: 10px;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 14px;
    }

    #sidebar h3 {
      margin: 0 0 10px 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #dee2e6;
    }

    .track-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin: 4px 0;
      background: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .track-item:hover {
      background: #e9ecef;
    }

    .track-item input {
      margin-right: 10px;
      flex-shrink: 0;
    }

    .track-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      margin-right: 8px;
      flex-shrink: 0;
    }

    .track-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .track-distance {
      color: #666;
      margin-left: 8px;
      white-space: nowrap;
      font-size: 12px;
    }

    #map {
      flex: 1;
      height: 100vh;
    }

    .controls {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #dee2e6;
    }

    .controls button {
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }

    .tile-controls {
      margin-bottom: 10px;
      padding: 10px;
      background: white;
      border-radius: 4px;
    }

    .tile-controls label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .tile-controls input {
      margin-right: 8px;
    }

    .tile-stats {
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }

    .tile-stats .count {
      font-weight: bold;
      color: #333;
      font-size: 16px;
    }

    .gemeinde-tooltip {
      font-size: 13px;
    }

    .gemeinde-tooltip b {
      font-size: 14px;
    }

    .import-controls {
      margin-bottom: 10px;
      padding: 10px;
      background: #e8f4e8;
      border-radius: 4px;
      border: 1px solid #c3e6c3;
    }

    .import-controls h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
    }

    .import-controls button {
      width: 100%;
      padding: 8px 12px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-bottom: 8px;
    }

    .import-controls button:hover {
      background: #218838;
    }

    .import-controls button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    .import-controls label {
      display: flex;
      align-items: center;
      font-size: 13px;
      cursor: pointer;
    }

    .import-controls input {
      margin-right: 8px;
    }

    .import-status {
      margin-top: 8px;
      padding: 6px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
    }

    .import-status.success {
      background: #d4edda;
      color: #155724;
      display: block;
    }

    .import-status.error {
      background: #f8d7da;
      color: #721c24;
      display: block;
    }

    .import-status.loading {
      background: #fff3cd;
      color: #856404;
      display: block;
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <h3>GPX Tracks</h3>
    <div class="import-controls">
      <h4>üì• Strava Import</h4>
      <div id="auth-section">
        <button id="auth-btn" onclick="startAuth()" style="background: #fc4c02;">Bei Strava anmelden</button>
        <div id="auth-status" style="font-size: 12px; margin-top: 5px; color: #666;"></div>
      </div>
      <button id="import-btn" onclick="fetchActivities()">Neue Aktivit√§ten abrufen</button>
      <label>
        <input type="checkbox" id="fetch-all">
        Alle abrufen (auch bereits importierte)
      </label>
      <div id="import-status" class="import-status"></div>
    </div>
    <div class="tile-controls">
      <label>
        <input type="checkbox" id="show-tiles" checked>
        Besuchte Tiles anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-gemeinden" checked>
        Gemeindegrenzen (DVG) anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-kreise" checked>
        Kreisgrenzen (DVG) anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-sachsen-gemeinden" checked>
        Gemeindegrenzen (Sachsen) anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-sachsen-kreise" checked>
        Kreisgrenzen (Sachsen) anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-thueringen-gemeinden" checked>
        Gemeindegrenzen (Th√ºringen) anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-thueringen-kreise" checked>
        Kreisgrenzen (Th√ºringen) anzeigen
      </label>
      <div class="tile-stats">
        <span class="count" id="tile-count">-</span> Tiles besucht (Zoom 14)<br>
        <span class="count" id="total-distance">-</span> km Gesamtdistanz<br>
        <span class="count" id="total-elevation">-</span> hm Gesamt<br>
        <span id="activity-count">-</span> Aktivit√§ten<br>
        <span class="count" id="eddington">-</span> Eddington (km)<br>
        <span class="count" id="max-cluster">-</span> Yard<br>
        <span class="count" id="max-square">-</span> √úbersquadrat
      </div>
      <label style="margin-top: 8px; display: block;">
        <input type="checkbox" id="show-cluster" checked>
        Yard anzeigen
      </label>
      <label>
        <input type="checkbox" id="show-square" checked>
        √úbersquadrat anzeigen
      </label>
    </div>
    <div class="controls">
      <button onclick="toggleAll(true)">Alle an</button>
      <button onclick="toggleAll(false)">Alle aus</button>
    </div>
    <div id="track-list"></div>
  </div>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([51.25, 12.14], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Create custom panes for z-ordering: gemeinden below kreise below tiles
    map.createPane('gemeindenPane');
    map.getPane('gemeindenPane').style.zIndex = 380;

    map.createPane('kreisePane');
    map.getPane('kreisePane').style.zIndex = 400;

    map.createPane('tilesPane');
    map.getPane('tilesPane').style.zIndex = 450;

    // Panes for Sachsen layers
    map.createPane('sachsenGemeindenPane');
    map.getPane('sachsenGemeindenPane').style.zIndex = 355;

    map.createPane('sachsenKreisePane');
    map.getPane('sachsenKreisePane').style.zIndex = 405;

    // Panes for Th√ºringen layers
    map.createPane('thueringenGemeindenPane');
    map.getPane('thueringenGemeindenPane').style.zIndex = 356;

    map.createPane('thueringenKreisePane');
    map.getPane('thueringenKreisePane').style.zIndex = 406;

    const tracks = {};
    const tilesLayer = L.layerGroup().addTo(map);
    const gemeindenLayer = L.layerGroup().addTo(map);
    const kreiseLayer = L.layerGroup().addTo(map);
    const sachsenGemeindenLayer = L.layerGroup().addTo(map);
    const sachsenKreiseLayer = L.layerGroup().addTo(map);
    const thueringenGemeindenLayer = L.layerGroup().addTo(map);
    const thueringenKreiseLayer = L.layerGroup().addTo(map);
    let tilesVisible = true;

    // Convert tile coordinates to lat/lon bounds
    function tileToLatLngBounds(x, y, z) {
      const n = Math.pow(2, z);
      const lonMin = x / n * 360.0 - 180.0;
      const lonMax = (x + 1) / n * 360.0 - 180.0;
      const latMax = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180.0 / Math.PI;
      const latMin = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180.0 / Math.PI;
      return L.latLngBounds([latMin, lonMin], [latMax, lonMax]);
    }

    // Format timestamp to readable date
    function formatTileDate(timestamp) {
      if (!timestamp || timestamp === 0) {
        return 'Datum unbekannt';
      }
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Get color based on how recent the tile was visited
    // Newest = dark green, oldest = light green/yellow
    function getTileColor(timestamp, minTime, maxTime) {
      if (!timestamp || timestamp === 0 || minTime === maxTime) {
        return '#90EE90'; // Light green for unknown dates
      }

      // Calculate ratio: 1 = newest, 0 = oldest
      const ratio = (timestamp - minTime) / (maxTime - minTime);

      // Gradient from light green (oldest) to dark green (newest)
      // Light green: rgb(144, 238, 144) -> Dark green: rgb(34, 139, 34)
      const r = Math.round(144 - ratio * 110);
      const g = Math.round(238 - ratio * 99);
      const b = Math.round(144 - ratio * 110);

      return `rgb(${r}, ${g}, ${b})`;
    }

    // Load stats (total distance, activity count, eddington, max square, max cluster)
    function loadStats() {
      fetch('/stats').then(r => r.json()).then(data => {
        document.getElementById('total-distance').textContent = data.total_distance_km.toFixed(2);
        document.getElementById('total-elevation').textContent = data.total_elevation_m.toLocaleString('de-DE');
        document.getElementById('activity-count').textContent = data.activity_count;
        document.getElementById('eddington').textContent = data.eddington;
        document.getElementById('max-square').textContent = data.max_square + 'x' + data.max_square;
        document.getElementById('max-cluster').textContent = data.max_cluster;
      }).catch(e => console.error('Failed to load stats:', e));
    }

    // Load stats on page load
    loadStats();

    // Load and display visited tiles
    function loadTiles() {
      fetch('/tiles').then(r => r.json()).then(data => {
        document.getElementById('tile-count').textContent = data.total_count;

        // Find min and max timestamps for color scaling
        const timestamps = data.tiles
          .map(t => t.first_visited_at)
          .filter(t => t && t > 0);
        const minTime = Math.min(...timestamps);
        const maxTime = Math.max(...timestamps);

        data.tiles.forEach(tile => {
          const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
          const dateStr = formatTileDate(tile.first_visited_at);
          const title = tile.activity_title || 'Unbekannt';
          const activityId = tile.activity_id || '';
          const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);

          let tooltipContent = `<b>${title}</b><br>`;
          tooltipContent += `Erste Durchfahrt: ${dateStr}`;
          if (activityId) {
            tooltipContent += `<br>ID: ${activityId}`;
          }

          const rect = L.rectangle(bounds, {
            color: tileColor,
            weight: 1,
            fillColor: tileColor,
            fillOpacity: 0.5,
            interactive: true
          });
          rect.bindTooltip(tooltipContent, {
            sticky: true,
            direction: 'top'
          });
          tilesLayer.addLayer(rect);
        });
      });
    }

    // Layer for max square and max cluster
    const squareLayer = L.layerGroup().addTo(map);
    const clusterLayer = L.layerGroup().addTo(map);

    // Load and display max square and cluster outlines
    function loadSquareCluster() {
      fetch('/square-cluster').then(r => r.json()).then(data => {
        squareLayer.clearLayers();
        clusterLayer.clearLayers();

        // Draw Yard (max cluster) outline (purple)
        if (data.max_cluster.size > 0) {
          // Draw each tile of the Yard
          const clusterBounds = calculateClusterOutline(data.max_cluster.tiles);
          clusterBounds.forEach(bounds => {
            const clusterRect = L.rectangle(bounds, {
              color: '#7b1fa2',
              weight: 2,
              fillColor: '#9c27b0',
              fillOpacity: 0.45,
              interactive: false
            });
            clusterLayer.addLayer(clusterRect);
          });

          // Add a single tooltip for the Yard
          if (data.max_cluster.tiles.length > 0) {
            const firstTile = data.max_cluster.tiles[0];
            const center = [
              (firstTile[0][0] + firstTile[1][0]) / 2,
              (firstTile[0][1] + firstTile[1][1]) / 2
            ];
            const marker = L.circleMarker(center, { radius: 0, opacity: 0 });
            marker.bindTooltip(`Yard: ${data.max_cluster.size} Tiles`, {
              permanent: false,
              direction: 'top'
            });
            clusterLayer.addLayer(marker);
          }
        }

        // Draw √úbersquadrat outline (purple, brighter)
        if (data.max_square.size > 0) {
          const squareBounds = [
            [data.max_square.bounds[0][0], data.max_square.bounds[0][1]],
            [data.max_square.bounds[1][0], data.max_square.bounds[1][1]]
          ];
          const squareRect = L.rectangle(squareBounds, {
            color: '#6a1b9a',
            weight: 4,
            fillColor: '#ab47bc',
            fillOpacity: 0.5,
            interactive: true
          });
          squareRect.bindTooltip(`√úbersquadrat: ${data.max_square.size}x${data.max_square.size}`, {
            sticky: true,
            direction: 'top'
          });
          squareLayer.addLayer(squareRect);
        }
      }).catch(e => console.error('Failed to load square/cluster:', e));
    }

    // Helper function to calculate cluster outline as array of tile bounds
    function calculateClusterOutline(tiles) {
      return tiles.map(t => [[t[0][0], t[0][1]], [t[1][0], t[1][1]]]);
    }

    // Load square/cluster on page load
    loadSquareCluster();

    // Toggle square visibility
    let squareVisible = true;
    document.getElementById('show-square').addEventListener('change', (e) => {
      squareVisible = e.target.checked;
      if (squareVisible) {
        squareLayer.addTo(map);
      } else {
        squareLayer.remove();
      }
    });

    // Toggle cluster visibility
    let clusterVisible = true;
    document.getElementById('show-cluster').addEventListener('change', (e) => {
      clusterVisible = e.target.checked;
      if (clusterVisible) {
        clusterLayer.addTo(map);
      } else {
        clusterLayer.remove();
      }
    });

    // Toggle tiles visibility
    document.getElementById('show-tiles').addEventListener('change', (e) => {
      tilesVisible = e.target.checked;
      if (tilesVisible) {
        tilesLayer.addTo(map);
      } else {
        tilesLayer.remove();
      }
    });

    // Toggle Gemeinden visibility
    let gemeindenVisible = true;
    document.getElementById('show-gemeinden').addEventListener('change', (e) => {
      gemeindenVisible = e.target.checked;
      if (gemeindenVisible) {
        gemeindenLayer.addTo(map);
      } else {
        gemeindenLayer.remove();
      }
    });

    // Toggle Kreise visibility
    let kreiseVisible = true;
    document.getElementById('show-kreise').addEventListener('change', (e) => {
      kreiseVisible = e.target.checked;
      if (kreiseVisible) {
        kreiseLayer.addTo(map);
      } else {
        kreiseLayer.remove();
      }
    });

    // Toggle Sachsen Gemeinden visibility
    let sachsenGemeindenVisible = true;
    document.getElementById('show-sachsen-gemeinden').addEventListener('change', (e) => {
      sachsenGemeindenVisible = e.target.checked;
      if (sachsenGemeindenVisible) {
        sachsenGemeindenLayer.addTo(map);
      } else {
        sachsenGemeindenLayer.remove();
      }
    });

    // Toggle Sachsen Kreise visibility
    let sachsenKreiseVisible = true;
    document.getElementById('show-sachsen-kreise').addEventListener('change', (e) => {
      sachsenKreiseVisible = e.target.checked;
      if (sachsenKreiseVisible) {
        sachsenKreiseLayer.addTo(map);
      } else {
        sachsenKreiseLayer.remove();
      }
    });

    // Toggle Th√ºringen Gemeinden visibility
    let thueringenGemeindenVisible = true;
    document.getElementById('show-thueringen-gemeinden').addEventListener('change', (e) => {
      thueringenGemeindenVisible = e.target.checked;
      if (thueringenGemeindenVisible) {
        thueringenGemeindenLayer.addTo(map);
      } else {
        thueringenGemeindenLayer.remove();
      }
    });

    // Toggle Th√ºringen Kreise visibility
    let thueringenKreiseVisible = true;
    document.getElementById('show-thueringen-kreise').addEventListener('change', (e) => {
      thueringenKreiseVisible = e.target.checked;
      if (thueringenKreiseVisible) {
        thueringenKreiseLayer.addTo(map);
      } else {
        thueringenKreiseLayer.remove();
      }
    });

    // Store tiles globally for gemeinde calculation
    let allTiles = [];
    const TILE_ZOOM = 14;

    // Convert lat/lon to tile coordinates
    function latLonToTile(lat, lon, zoom) {
      const n = Math.pow(2, zoom);
      const x = Math.floor((lon + 180.0) / 360.0 * n);
      const latRad = lat * Math.PI / 180.0;
      const y = Math.floor((1.0 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2.0 * n);
      return { x, y };
    }

    // Get tile center coordinates
    function tileCenterToLatLon(x, y, zoom) {
      const n = Math.pow(2, zoom);
      const lon = (x + 0.5) / n * 360.0 - 180.0;
      const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 0.5) / n)));
      const lat = latRad * 180.0 / Math.PI;
      return [lat, lon];
    }

    // Check if a point is inside a polygon
    function pointInPolygon(point, polygon) {
      const x = point[1], y = point[0]; // lon, lat
      let inside = false;

      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];

        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // Check if a point is in any polygon of a MultiPolygon or Polygon
    function pointInGeometry(point, geometry) {
      if (geometry.type === 'Polygon') {
        return pointInPolygon(point, geometry.coordinates[0]);
      } else if (geometry.type === 'MultiPolygon') {
        for (const poly of geometry.coordinates) {
          if (pointInPolygon(point, poly[0])) {
            return true;
          }
        }
      }
      return false;
    }

    // Get all tiles that fall within a geometry's bounding box, then filter
    function getTilesInGeometry(geometry, visitedTileSet) {
      // Get bounding box
      let minLat = Infinity, maxLat = -Infinity;
      let minLon = Infinity, maxLon = -Infinity;

      const coords = geometry.type === 'Polygon'
        ? [geometry.coordinates]
        : geometry.coordinates;

      for (const poly of coords) {
        for (const ring of poly) {
          for (const [lon, lat] of ring) {
            minLat = Math.min(minLat, lat);
            maxLat = Math.max(maxLat, lat);
            minLon = Math.min(minLon, lon);
            maxLon = Math.max(maxLon, lon);
          }
        }
      }

      // Get tile range for bounding box
      const topLeft = latLonToTile(maxLat, minLon, TILE_ZOOM);
      const bottomRight = latLonToTile(minLat, maxLon, TILE_ZOOM);

      let totalTiles = 0;
      let visitedTiles = 0;

      // Check each tile in the bounding box
      for (let x = topLeft.x; x <= bottomRight.x; x++) {
        for (let y = topLeft.y; y <= bottomRight.y; y++) {
          const center = tileCenterToLatLon(x, y, TILE_ZOOM);
          if (pointInGeometry(center, geometry)) {
            totalTiles++;
            if (visitedTileSet.has(`${x},${y}`)) {
              visitedTiles++;
            }
          }
        }
      }

      return { totalTiles, visitedTiles };
    }

    // Store gemeinden data globally for tile lookups
    let gemeindenData = [];
    let kreiseData = [];
    let sachsenGemeindenData = [];
    let sachsenKreiseData = [];
    let thueringenGemeindenData = [];
    let thueringenKreiseData = [];

    // Find which kreis a point belongs to (using kreiseData)
    function findKreisForPoint(lat, lon) {
      const point = [lat, lon];
      for (const kreis of kreiseData) {
        if (pointInGeometry(point, kreis.geometry)) {
          return kreis;
        }
      }
      return null;
    }

    // Load Gemeinden and Kreise, calculate statistics
    function loadGemeinden() {
      // First, create a set of visited tiles for fast lookup
      const visitedTileSet = new Set(allTiles.map(t => `${t.x},${t.y}`));

      fetch('/gemeinden.geojson')
        .then(r => r.json())
        .then(geojson => {
          // Filter Gemeinden
          const gemeinden = geojson.features.filter(f =>
            f.properties.Art === 'Gemeinde' ||
            f.properties.Art === 'Stadt' ||
            f.properties.Art === 'Kreisfreie Stadt'
          );

          // Filter Kreise
          const kreise = geojson.features.filter(f =>
            f.properties.Art === 'Kreis / kreisfreie Stadt'
          );

          // FIRST: Process Kreise data (need this for gemeinde tooltips)
          kreise.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.Name || 'Unbekannt';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            kreiseData.push({
              name: name,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });
          });

          // SECOND: Render Kreise layers
          kreiseData.forEach(kreisInfo => {
            const layer = L.geoJSON({ type: 'Feature', geometry: kreisInfo.geometry }, {
              pane: 'kreisePane',
              style: {
                color: '#000000',
                weight: 3,
                fillColor: '#000000',
                fillOpacity: 0.01,
                interactive: true
              }
            });

            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>Kreis: ${kreisInfo.name}</b><br>`;
            tooltipContent += `Tiles: ${kreisInfo.stats.visitedTiles} / ${kreisInfo.stats.totalTiles}`;
            if (kreisInfo.stats.totalTiles > 0) {
              tooltipContent += ` (${kreisInfo.percent}%)`;
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            kreiseLayer.addLayer(layer);
          });

          // THIRD: Process Gemeinden with Kreis info in tooltip
          gemeinden.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.Name || 'Unbekannt';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            // Get centroid of gemeinde to find its kreis
            const bounds = L.geoJSON(feature).getBounds();
            const center = bounds.getCenter();
            const kreis = findKreisForPoint(center.lat, center.lng);

            gemeindenData.push({
              name: name,
              geometry: feature.geometry,
              stats: stats,
              percent: percent,
              kreis: kreis
            });

            const layer = L.geoJSON(feature, {
              pane: 'gemeindenPane',
              style: {
                color: '#888888',
                weight: 2,
                fillColor: '#888888',
                fillOpacity: 0.01,
                interactive: true
              }
            });

            // Build tooltip with gemeinde + kreis info
            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>${name}</b><br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }

            // Add kreis info
            if (kreis) {
              tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
              tooltipContent += `<b>Kreis: ${kreis.name}</b><br>`;
              tooltipContent += `Tiles: ${kreis.stats.visitedTiles} / ${kreis.stats.totalTiles}`;
              if (kreis.stats.totalTiles > 0) {
                tooltipContent += ` (${kreis.percent}%)`;
              }
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            gemeindenLayer.addLayer(layer);
          });

          // Now update tile tooltips with gemeinde info
          updateTileTooltipsWithGemeinden();
        })
        .catch(err => console.error('Error loading Gemeinden:', err));
    }

    // Load Sachsen boundaries (Gemeinden and Kreise)
    function loadSachsenBoundaries() {
      const visitedTileSet = new Set(allTiles.map(t => `${t.x},${t.y}`));

      // Load Sachsen Kreise first
      fetch('/sachsen_kreise.geojson')
        .then(r => r.json())
        .then(geojson => {
          geojson.features.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.KREIS || 'Unbekannt';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            // Store for tile lookup
            sachsenKreiseData.push({
              name: name,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });

            const layer = L.geoJSON({ type: 'Feature', geometry: feature.geometry }, {
              pane: 'sachsenKreisePane',
              style: {
                color: '#8b0000',
                weight: 3,
                fillColor: '#8b0000',
                fillOpacity: 0.01,
                interactive: true
              }
            });

            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>Kreis (Sachsen): ${name}</b><br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            sachsenKreiseLayer.addLayer(layer);
          });
        })
        .catch(err => console.error('Error loading Sachsen Kreise:', err));

      // Load Sachsen Gemeinden
      fetch('/sachsen_gemeinden.geojson')
        .then(r => r.json())
        .then(geojson => {
          geojson.features.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.ORTSNAME || 'Unbekannt';
            const kreisName = feature.properties.KREIS || '';
            const admin = feature.properties.ADMIN || '';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            // Store for tile lookup
            sachsenGemeindenData.push({
              name: name,
              kreisName: kreisName,
              admin: admin,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });

            // Color based on completion
            let fillColor = '#ff6b6b';
            if (percent >= 100) {
              fillColor = '#51cf66';
            } else if (percent >= 50) {
              fillColor = '#ffd43b';
            } else if (percent >= 25) {
              fillColor = '#ff922b';
            }

            const layer = L.geoJSON({ type: 'Feature', geometry: feature.geometry }, {
              pane: 'sachsenGemeindenPane',
              style: {
                color: '#333',
                weight: 1,
                fillColor: fillColor,
                fillOpacity: 0.25,
                interactive: true
              }
            });

            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>${name}</b>`;
            if (admin) {
              tooltipContent += ` (${admin})`;
            }
            tooltipContent += `<br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }
            if (kreisName) {
              tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
              tooltipContent += `Kreis: ${kreisName}`;
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            sachsenGemeindenLayer.addLayer(layer);
          });
        })
        .catch(err => console.error('Error loading Sachsen Gemeinden:', err));
    }

    // Load Th√ºringen boundaries (Gemeinden and Kreise)
    function loadThueringenBoundaries() {
      const visitedTileSet = new Set(allTiles.map(t => `${t.x},${t.y}`));

      // Load Th√ºringen Kreise first
      fetch('/thueringen_kreise.geojson')
        .then(r => r.json())
        .then(geojson => {
          geojson.features.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.LK || 'Unbekannt';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            // Store for tile lookup
            thueringenKreiseData.push({
              name: name,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });

            const layer = L.geoJSON({ type: 'Feature', geometry: feature.geometry }, {
              pane: 'thueringenKreisePane',
              style: {
                color: '#006400',
                weight: 3,
                fillColor: '#006400',
                fillOpacity: 0.01,
                interactive: true
              }
            });

            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>Kreis (Th√ºringen): ${name}</b><br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            thueringenKreiseLayer.addLayer(layer);
          });
        })
        .catch(err => console.error('Error loading Th√ºringen Kreise:', err));

      // Load Th√ºringen Gemeinden
      fetch('/thueringen_gemeinden.geojson')
        .then(r => r.json())
        .then(geojson => {
          geojson.features.forEach(feature => {
            const stats = getTilesInGeometry(feature.geometry, visitedTileSet);
            const name = feature.properties.GMD || 'Unbekannt';
            const kreisName = feature.properties.LK || '';
            const percent = stats.totalTiles > 0
              ? Math.round(stats.visitedTiles / stats.totalTiles * 100)
              : 0;

            // Store for tile lookup
            thueringenGemeindenData.push({
              name: name,
              kreisName: kreisName,
              geometry: feature.geometry,
              stats: stats,
              percent: percent
            });

            // Color based on completion
            let fillColor = '#ff6b6b';
            if (percent >= 100) {
              fillColor = '#51cf66';
            } else if (percent >= 50) {
              fillColor = '#ffd43b';
            } else if (percent >= 25) {
              fillColor = '#ff922b';
            }

            const layer = L.geoJSON({ type: 'Feature', geometry: feature.geometry }, {
              pane: 'thueringenGemeindenPane',
              style: {
                color: '#333',
                weight: 1,
                fillColor: fillColor,
                fillOpacity: 0.25,
                interactive: true
              }
            });

            let tooltipContent = `<div class="gemeinde-tooltip">`;
            tooltipContent += `<b>${name}</b>`;
            tooltipContent += `<br>`;
            tooltipContent += `Tiles: ${stats.visitedTiles} / ${stats.totalTiles}`;
            if (stats.totalTiles > 0) {
              tooltipContent += ` (${percent}%)`;
            }
            if (kreisName) {
              tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
              tooltipContent += `Kreis: ${kreisName}`;
            }
            tooltipContent += `</div>`;

            layer.bindTooltip(tooltipContent, {
              sticky: true,
              direction: 'top'
            });

            thueringenGemeindenLayer.addLayer(layer);
          });
        })
        .catch(err => console.error('Error loading Th√ºringen Gemeinden:', err));
    }

    // Find which kreis a tile belongs to
    function findKreisForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const kreis of kreiseData) {
        if (pointInGeometry(center, kreis.geometry)) {
          return kreis;
        }
      }
      return null;
    }

    // Find which gemeinde a tile belongs to
    function findGemeindeForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const gemeinde of gemeindenData) {
        if (pointInGeometry(center, gemeinde.geometry)) {
          return gemeinde;
        }
      }
      return null;
    }

    // Find which Sachsen kreis a tile belongs to
    function findSachsenKreisForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const kreis of sachsenKreiseData) {
        if (pointInGeometry(center, kreis.geometry)) {
          return kreis;
        }
      }
      return null;
    }

    // Find which Sachsen gemeinde a tile belongs to
    function findSachsenGemeindeForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const gemeinde of sachsenGemeindenData) {
        if (pointInGeometry(center, gemeinde.geometry)) {
          return gemeinde;
        }
      }
      return null;
    }

    // Find which Th√ºringen kreis a tile belongs to
    function findThueringenKreisForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const kreis of thueringenKreiseData) {
        if (pointInGeometry(center, kreis.geometry)) {
          return kreis;
        }
      }
      return null;
    }

    // Find which Th√ºringen gemeinde a tile belongs to
    function findThueringenGemeindeForTile(tileX, tileY) {
      const center = tileCenterToLatLon(tileX, tileY, TILE_ZOOM);
      for (const gemeinde of thueringenGemeindenData) {
        if (pointInGeometry(center, gemeinde.geometry)) {
          return gemeinde;
        }
      }
      return null;
    }

    // Update tile tooltips after gemeinden are loaded
    function updateTileTooltipsWithGemeinden() {
      // Clear and rebuild tiles layer with gemeinde info
      tilesLayer.clearLayers();

      const timestamps = allTiles
        .map(t => t.first_visited_at)
        .filter(t => t && t > 0);
      const minTime = Math.min(...timestamps);
      const maxTime = Math.max(...timestamps);

      allTiles.forEach(tile => {
        const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
        const dateStr = formatTileDate(tile.first_visited_at);
        const title = tile.activity_title || 'Unbekannt';
        const activityId = tile.activity_id || '';
        const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);

        // Find gemeinde for this tile
        const gemeinde = findGemeindeForTile(tile.x, tile.y);
        const kreis = findKreisForTile(tile.x, tile.y);

        let tooltipContent = `<b>${title}</b><br>`;
        tooltipContent += `Erste Durchfahrt: ${dateStr}`;
        if (activityId) {
          tooltipContent += `<br>ID: ${activityId}`;
        }

        // Add gemeinde info if found
        if (gemeinde) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>${gemeinde.name}</b><br>`;
          tooltipContent += `Tiles: ${gemeinde.stats.visitedTiles} / ${gemeinde.stats.totalTiles}`;
          if (gemeinde.stats.totalTiles > 0) {
            tooltipContent += ` (${gemeinde.percent}%)`;
          }
        }

        // Add kreis info if found
        if (kreis) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>Kreis: ${kreis.name}</b><br>`;
          tooltipContent += `Tiles: ${kreis.stats.visitedTiles} / ${kreis.stats.totalTiles}`;
          if (kreis.stats.totalTiles > 0) {
            tooltipContent += ` (${kreis.percent}%)`;
          }
        }

        // Add Sachsen gemeinde info if found
        const sachsenGemeinde = findSachsenGemeindeForTile(tile.x, tile.y);
        if (sachsenGemeinde) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>${sachsenGemeinde.name}</b><br>`;
          tooltipContent += `Tiles: ${sachsenGemeinde.stats.visitedTiles} / ${sachsenGemeinde.stats.totalTiles}`;
          if (sachsenGemeinde.stats.totalTiles > 0) {
            tooltipContent += ` (${sachsenGemeinde.percent}%)`;
          }
        }

        // Add Sachsen kreis info if found
        const sachsenKreis = findSachsenKreisForTile(tile.x, tile.y);
        if (sachsenKreis) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>Kreis: ${sachsenKreis.name}</b><br>`;
          tooltipContent += `Tiles: ${sachsenKreis.stats.visitedTiles} / ${sachsenKreis.stats.totalTiles}`;
          if (sachsenKreis.stats.totalTiles > 0) {
            tooltipContent += ` (${sachsenKreis.percent}%)`;
          }
        }

        // Add Th√ºringen gemeinde info if found
        const thueringenGemeinde = findThueringenGemeindeForTile(tile.x, tile.y);
        if (thueringenGemeinde) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>${thueringenGemeinde.name}</b><br>`;
          tooltipContent += `Tiles: ${thueringenGemeinde.stats.visitedTiles} / ${thueringenGemeinde.stats.totalTiles}`;
          if (thueringenGemeinde.stats.totalTiles > 0) {
            tooltipContent += ` (${thueringenGemeinde.percent}%)`;
          }
        }

        // Add Th√ºringen kreis info if found
        const thueringenKreis = findThueringenKreisForTile(tile.x, tile.y);
        if (thueringenKreis) {
          tooltipContent += `<hr style="margin: 4px 0; border: none; border-top: 1px solid #ccc;">`;
          tooltipContent += `<b>Kreis: ${thueringenKreis.name}</b><br>`;
          tooltipContent += `Tiles: ${thueringenKreis.stats.visitedTiles} / ${thueringenKreis.stats.totalTiles}`;
          if (thueringenKreis.stats.totalTiles > 0) {
            tooltipContent += ` (${thueringenKreis.percent}%)`;
          }
        }

        const rect = L.rectangle(bounds, {
          pane: 'tilesPane',
          color: tileColor,
          weight: 1,
          fillColor: tileColor,
          fillOpacity: 0.5,
          interactive: true
        });
        rect.bindTooltip(tooltipContent, {
          sticky: true,
          direction: 'top'
        });
        tilesLayer.addLayer(rect);
      });
    }

    // Modified loadTiles to also trigger Gemeinden loading
    const originalLoadTiles = loadTiles;
    loadTiles = function () {
      fetch('/tiles').then(r => r.json()).then(data => {
        document.getElementById('tile-count').textContent = data.total_count;
        allTiles = data.tiles; // Store for gemeinde calculation

        // Find min and max timestamps for color scaling
        const timestamps = data.tiles
          .map(t => t.first_visited_at)
          .filter(t => t && t > 0);
        const minTime = Math.min(...timestamps);
        const maxTime = Math.max(...timestamps);

        data.tiles.forEach(tile => {
          const bounds = tileToLatLngBounds(tile.x, tile.y, tile.z);
          const dateStr = formatTileDate(tile.first_visited_at);
          const title = tile.activity_title || 'Unbekannt';
          const activityId = tile.activity_id || '';
          const tileColor = getTileColor(tile.first_visited_at, minTime, maxTime);

          let tooltipContent = `<b>${title}</b><br>`;
          tooltipContent += `Erste Durchfahrt: ${dateStr}`;
          if (activityId) {
            tooltipContent += `<br>ID: ${activityId}`;
          }

          const rect = L.rectangle(bounds, {
            pane: 'tilesPane',
            color: tileColor,
            weight: 1,
            fillColor: tileColor,
            fillOpacity: 0.5,
            interactive: true
          });
          rect.bindTooltip(tooltipContent, {
            sticky: true,
            direction: 'top'
          });
          tilesLayer.addLayer(rect);
        });

        // Now load Gemeinden with tile data available
        loadGemeinden();
        // Load Sachsen boundaries
        loadSachsenBoundaries();
        // Load Th√ºringen boundaries
        loadThueringenBoundaries();
      });
    };

    // Load tiles on startup
    loadTiles();

    // Generate color gradient from red (newest) to green (oldest)
    function getGradientColor(index, total) {
      if (total <= 1) return '#e6194b'; // red for single track
      const ratio = index / (total - 1);
      // Red: rgb(230, 25, 75) -> Green: rgb(60, 180, 75)
      const r = Math.round(230 - ratio * 170);
      const g = Math.round(25 + ratio * 155);
      const b = Math.round(75);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('de-DE', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function updateBounds() {
      const visibleBounds = [];
      Object.values(tracks).forEach(t => {
        if (t.visible && t.polyline) visibleBounds.push(t.polyline.getBounds());
      });
      if (visibleBounds.length > 0) {
        let bounds = visibleBounds[0];
        visibleBounds.slice(1).forEach(b => bounds.extend(b));
        map.fitBounds(bounds);
      }
    }

    function toggleTrack(file, visible) {
      const track = tracks[file];
      if (!track || !track.polyline) return;
      track.visible = visible;
      if (visible) { track.polyline.addTo(map); } else { track.polyline.remove(); }
    }

    function toggleAll(visible) {
      Object.keys(tracks).forEach(file => {
        const checkbox = document.getElementById('chk-' + file);
        if (checkbox) checkbox.checked = visible;
        toggleTrack(file, visible);
      });
    }

    // Check authentication status on load
    async function checkAuthStatus() {
      try {
        const response = await fetch('/auth/status');
        const result = await response.json();
        const authStatus = document.getElementById('auth-status');
        const authBtn = document.getElementById('auth-btn');

        if (result.authenticated) {
          authStatus.textContent = '‚úÖ Authentifiziert';
          authStatus.style.color = '#28a745';
          authBtn.style.display = 'none';
        } else {
          authStatus.textContent = 'Nicht angemeldet';
          authStatus.style.color = '#666';
        }
      } catch (e) {
        console.error('Auth status check failed:', e);
      }
    }

    // Start Strava OAuth
    async function startAuth() {
      const authBtn = document.getElementById('auth-btn');
      const authStatus = document.getElementById('auth-status');

      authBtn.disabled = true;
      authStatus.textContent = 'Starte Authentifizierung...';

      try {
        const response = await fetch('/auth/start');
        const result = await response.json();

        if (result.success && result.auth_url) {
          // Open Strava auth in new window
          const authWindow = window.open(result.auth_url, 'strava-auth', 'width=600,height=700');
          authStatus.textContent = 'Bitte im Popup-Fenster anmelden...';

          // Listen for success message from popup
          window.addEventListener('message', function handler(event) {
            if (event.data && event.data.type === 'strava-auth-success') {
              window.removeEventListener('message', handler);
              authStatus.textContent = '‚úÖ Erfolgreich authentifiziert!';
              authStatus.style.color = '#28a745';
              authBtn.style.display = 'none';
            }
          });

          // Also poll for status in case postMessage doesn't work
          const pollInterval = setInterval(async () => {
            try {
              const statusResp = await fetch('/auth/status');
              const status = await statusResp.json();
              if (status.authenticated) {
                clearInterval(pollInterval);
                authStatus.textContent = '‚úÖ Erfolgreich authentifiziert!';
                authStatus.style.color = '#28a745';
                authBtn.style.display = 'none';
              }
            } catch (e) { }
          }, 2000);

          // Stop polling after 2 minutes
          setTimeout(() => clearInterval(pollInterval), 120000);
        } else {
          authStatus.textContent = result.message || 'Fehler beim Starten der Authentifizierung';
          authStatus.style.color = '#dc3545';
        }
      } catch (error) {
        authStatus.textContent = 'Fehler: ' + error.message;
        authStatus.style.color = '#dc3545';
      } finally {
        authBtn.disabled = false;
      }
    }

    // Check auth status on page load
    checkAuthStatus();

    // Fetch activities from Strava
    async function fetchActivities() {
      const btn = document.getElementById('import-btn');
      const status = document.getElementById('import-status');
      const fetchAll = document.getElementById('fetch-all').checked;

      btn.disabled = true;
      btn.textContent = 'Wird abgerufen...';
      status.className = 'import-status loading';
      status.textContent = 'Verbinde mit Strava...';

      try {
        const response = await fetch('/fetch-activities', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fetch_all: fetchAll, per_page: 50, page: 1 })
        });

        const result = await response.json();

        if (result.success) {
          status.className = 'import-status success';
          status.textContent = result.message;

          // Reload the page to show new tracks and tiles
          if (result.imported > 0) {
            setTimeout(() => {
              status.textContent = result.message + ' ‚Äì Seite wird neu geladen...';
              window.location.reload();
            }, 1500);
          }
        } else {
          status.className = 'import-status error';
          status.textContent = result.message;
        }
      } catch (error) {
        status.className = 'import-status error';
        status.textContent = 'Fehler: ' + error.message;
      } finally {
        btn.disabled = false;
        btn.textContent = 'Neue Aktivit√§ten abrufen';
      }
    }

    fetch('/gpx').then(r => r.json()).then(files => {
      const listEl = document.getElementById('track-list');
      const total = files.length;

      files.forEach((fileInfo, index) => {
        const file = fileInfo.filename;
        const color = getGradientColor(index, total);
        tracks[file] = { color: color, polyline: null, visible: true };

        const item = document.createElement('label');
        item.className = 'track-item';
        const dateStr = formatDate(fileInfo.modified);
        const distStr = fileInfo.distance_km.toFixed(2) + ' km';
        const eleStr = fileInfo.elevation_gain_m + ' hm';
        item.innerHTML = '<input type="checkbox" id="chk-' + file + '" checked><span class="track-color" style="background:' + color + '"></span><span class="track-name">' + dateStr + '</span><span class="track-distance">' + distStr + ' / ' + eleStr + '</span>';
        item.querySelector('input').addEventListener('change', (e) => toggleTrack(file, e.target.checked));
        listEl.appendChild(item);

        fetch('/gpx/' + file).then(r => r.text()).then(gpxData => {
          const parser = new DOMParser();
          const gpx = parser.parseFromString(gpxData, 'text/xml');
          const trkpts = gpx.querySelectorAll('trkpt');
          if (trkpts.length === 0) return;
          const latlngs = [];
          trkpts.forEach(pt => {
            const lat = parseFloat(pt.getAttribute('lat'));
            const lon = parseFloat(pt.getAttribute('lon'));
            if (!isNaN(lat) && !isNaN(lon)) latlngs.push([lat, lon]);
          });
          if (latlngs.length > 0) {
            const polyline = L.polyline(latlngs, { color: color, weight: 3, opacity: 0.8 }).addTo(map);
            tracks[file].polyline = polyline;
            updateBounds();
          }
        });
      });
    });
  </script>
</body>

</html>